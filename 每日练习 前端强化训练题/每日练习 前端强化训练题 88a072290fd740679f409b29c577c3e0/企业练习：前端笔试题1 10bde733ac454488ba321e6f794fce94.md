# 企业练习：前端笔试题1

# 企业练习：前端笔试题1

![https://www.notion.so企业练习：前端笔试题1_files/微信图片_20190825214419.jpg](https://www.notion.so企业练习：前端笔试题1_files/微信图片_20190825214419.jpg)

1. 什么是响应式设计？它的原理是什么？如何兼容低版本的IE

首先，我们来聊聊响应式设计，响应式设计指的就是web设备丰富的今天，为了满足各种设备，可穿戴设备等屏幕的尺寸，为了能够在不同的尺寸下，呈现出较好的视觉效果（网站效果）叫做响应式设计

通常我们是通过js来监听网页的宽度/高度的变化，根据对应的尺寸，来进行不同元素的删除替换隐藏等，但是随着css3的媒体查询的技术成熟，目前包括bootstrap就采用了grid+媒体查询来适配设备，

这种方案也是目前主流的方案；但是css3在低版本的ie下会有适配问题，所以我们可以通过window对象下的 resize，尝试监听它，得到的不同尺寸，再根据不同尺寸做css样式，使用js替换对应的class类名即可，这个也是最稳妥且兼容性最好的一种做法；

2.css优化，提高性能的方式，其实在日常开发中（除了写ui库之外），我们应该避免使用大量的后代，类型选择器，一个一个嵌套，代码太臃肿，我们应该使用最为简洁的css写法，通常样式通过1-2个类名去划分一个区间，让css去渲染，那么这是为什么呢？因为css选择器的解析顺序是，从右到左，避免写太多臃肿的css（即避免浏览器过多的去判断父级是否是正确的匹配），而且尽量不要使用*和标签选择器，因为权重根据ICE计算公式，权重很低，很容易被覆盖掉，对于最重要的样式应该使用!important

3.如何竖直垂直居中一个元素，这是一个思维开放题，我们可以使用position定位，left:0;right:0;right:0;bottom:0;margin:0 aut0;

又可以借助于margin和calc函数: margin: 0 auto;margin-top: calc(50% - height)；那么同理，也可以使用transform：translataX；那么又同理，定位住各百分之50之后，也可以使用margin-left和margin-right根据自身的宽高进行调整

也可以使用flex或者grid进行布局：也可以使用table布局；单行文本也可以使用行高 = 父容器高度来实现效果

4.cookie和localstorage，sessionstorage的区别

cookie只能存储4k，通常是服务端生成，可以设置失效时间，也可以浏览器生成，默认是关闭浏览器失效，而且原生的cookie不好用，需要自己封装；localstorage是h5的新属性，但是并不是新功能，以前就有存储userdata的东西，一般内存是5m，不手动清除会永久存储不会清除；sessionstorage也可以存5m，但是仅在本此会话或者关闭浏览器清除，用法是和local一样的

5.首先我们输入一个网址域名，会通过DNS服务器找到ip地址，再通过ip地址去请求服务器，然后http的三次握手，服务端返回页面，然后会经过cssdom和htmldom的解析，并且挂载直到渲染成功，这个中间当然还有关于可能FOUC的后果，cssdom对htmldom的阻塞，js资源阻塞的问题

6.vue-router是vue周边提供的路由器，我们可以用vue-router实现vue在路由功能上的运用，它提供了丰富的api，比如路由的模块化配置，试图表，路由参数，通配符，HTML5的历史模式和hash模式，在ie9自动降级等，它有很多关于路由的钩子，比如路由前置，后置，解析守卫，组件内的守卫等，用的比较多的还是前置守卫；beforeEach

7.vue是一套用于构建用户view界面的js渐进式框架，vue允许我们在已成型的web项目中，使用vue组件进行单独的模块使用，还可以在大型单页项目中是用它，关于vue的双向数据绑定，原理则是用了Object.defineProperty的set函数实现了双向数据绑定；

8.我们讲从企业vue组件角度来说，如何构建一个高效简洁的vue组件，在网页中我们可以提炼公共部分，比如app中的头部，我们在头部组件中可以提供一系列的props以便组件有更多可供父组件自定义的功能，然后在组件中写一些功能的同时向父组件emit更多的事件，以便更好的和父组件交互

9.生命周期其实顾名思义，和人类一样，心脏随时在跳动，这就是和vue一样，它提供了系列的在某些时刻调用的方法钩子，我们可以在钩子处理一些需要的业务逻辑，比如很经典的路由传参，就可以通过created通过this.$route对象来接受；

10.闭包则是解决了外部函数无法访问到内部函数的变量这个问题，可以通过函数返回一个function，return栈中上层的变量，形成一个独立的作用域，但是不会销毁，如果我们不销毁可能会造成浏览器的内存泄露