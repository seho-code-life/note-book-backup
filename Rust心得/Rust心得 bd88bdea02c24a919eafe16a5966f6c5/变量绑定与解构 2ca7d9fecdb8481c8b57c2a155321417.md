# 变量绑定与解构

首先需要明确一点的是, rust中的变量不是赋值, 而是绑定, 这样含义更清楚; 因为变量涉及到所有权, 任何内存对象都是有主人的, 一般情况下是完全属于特定主人的, 绑定就是把这个对象绑定给一个变量, 那么该对象之前的主人就会丧失它的所有权.

## mut

变量可变使用mut关键字, 可以促使我们写出更灵活的代码, 但是不能修改类型;

> 总的来说，默认情况下都建议不可变。首先不是因为性能，而是因为这样可以极大地减少bug几率，在函数式思维的加持下非常容易写出*明显没有bug*的代码。只有涉及到大量临时变量、需要可变才能大幅优化性能或者可变才能比较方便实现的情况下，才建议用mut。
> 

## 使用_忽略未使用的变量

如果有未使用过的变量存在, 编译器会报错, 如果前面加_就会让编译器忽略错误

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

## 变量解构

let关键字不仅可以用于变量的绑定, 也可以使用复杂结构的解构;

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

## 常量

当一个值不能被更改, 这就是常量, 每一个语言都有这个概念, 但是rust中的常量有一点点不一样, 首先常量不允许使用刚刚提到的`mut`关键字, 而且值的类型必须标注, 且通常我们都需要大写(这也是每个语言的惯例)

```rust
const MAX_POINTS: u32 = 100_000;
```

## 变量遮蔽

简单来讲, 和js类似, 作用域的变量会替换上层的变量, 在同一层的变量会根据声明的顺序, 后面的会替换前面的, 这样就避免了很多问题, 就是起名字的问题, 有时候我们需要对一个已知的变量进行修改, 但是意义又和以前的变量一样, 所以这个很方便

```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```