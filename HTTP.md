# HTTP

本篇笔记主演描述http常见的概念以及历史

## 概念

HTTP是超文本传输协议, 一个词里面有3个关键信息

- 超文本
- 传输
- 协议

那么`超文本`的意思就是字面含义, 就是不止是文本, 也有可能是图片,音乐, 视频等等, 而`传输`和`协议`指的就是在计算机层面之上的一种交流约定方式, 那么我们可以理解为这个HTTP**可以允许我们在计算机上实现双向的传输交流的规范**

## Methods

每个http都有自己的method, 每个method对应的操作虽然是开发人员自定义实现的, 但是我们在编写操作逻辑时, 也要尽量遵守http method的语义标准

- GET和POST的区别

> 首先根据RFC的定义, GET是从服务端获取一个资源; 而POST是根据报文内容对资源去做对应的处理
> 
- GET和POST是安全的么, 它们都是幂等的吗?

> 首先根据HTTP定义的安全标准, 指的就是是否在服务端操作了数据, 一旦操作了数据, 其实这个请求就是不安全的; 幂等指的就是多次提交和一次提交的影响都是一样的, 显然GET只是获取服务器资源, 它是安全且幂等的; 反之, POST多次提交不一定和一次提交的影响是一样的, 所以POST是不安全且不幂等的
> 

## 缓存

在HTTP中缓存分为2种

- 协商缓存
- 强制缓存

当浏览器向服务端第一次请求资源时, 浏览器通常会缓存数据, 那么在下一次请求时如果资源还没过期, 将会使用缓存中的数据, 那么这就是强制缓存, 通常会在HTTP中显示(from disk cache), 强制缓存主要取决于客户端

而取决于服务端的HTTP就是协商缓存, 在协商缓存中的服务端会返回给客户端不同的响应头, 并且状态码是304, 即告知浏览器可以使用缓存, 大名鼎鼎的`Vite`在预构建依赖时, 就用了这种缓存方法优化了HTTP性能.

我们在学习协商缓存的时候, 也需要知道`最后修改时间`实现缓存的, 还是基于`ETAG`实现缓存的; 我们在业务使用中, 会选择ETAG实现 (并且浏览器机制下ETAG优先级更高), 因为ETAG解决了时间实现的几个缺陷:

- 时间只能精确到秒, 有时候修改文件是在秒之内, 所以最后修改时间存在误差
- 服务器可能获取不到最新的时间
- 我们关注的是文件内容本身, 虽然本身内容没有被修改, 但是最后修改时间可能会改变

> ETAG: 唯一资源标识符: 当第一次请求服务端会返回一个唯一标识, 客户端请求携带, 由服务端告知客户端是返回200 (被变更, 返回最新资源), 还是304(没有变更)
> 

> 协商缓存和强制缓存需要搭配使用, 当强制缓存未命中时, 再使用协商缓存
> 

## HTTP版本演变

我们在谈论HTTP版本时, 通常会谈论HTTP1.1和2.0以及3.0

首先, HTTP1.1相比HTTP1.0有哪些重要改进呢?

- 使用长连接改进了1.0时的短连接
- 支持pipeline网络传输, 不需要等待前一个请求返回再发出第二个

但是尽管改进了很多, 但是HTTP1.1还是有很多不足

- header不压缩, 只压缩了body部分
- 队头阻塞, 虽然可以发出请求可以不用等待之前的返回, 但是HTTP1.1是按照请求的顺序返回的, 如果前一个请求响应慢, 会造成之后的请求返回阻塞
- 发送了冗长的首部, 造成浪费
- 只能客户端主动发起请求

为了解决这些不足以及安全性问题, HTTP2.0诞生了, 解决了如下的痛点问题

- 发送二进制格式
- 头部压缩
- 并发传输, 解决了响应阻塞问题
- 服务器主动推送

### 头部压缩

头部压缩, 如果你同时发出了多个请求, 那么它们的头部都是一样的或者是相似的, 那么HTTP内部会使用`HPACK`算法对其进行处理, 大概的原理就是客户端和服务端共同维护一个表, 在表中存储各种的头信息, 每次没有必要发送冗长的头部, 只需要发送索引号即可.

### 二进制传输

二进制传输格式也大大提高了传输效率, 它们被称之为`帧(Frame)`, 分为头部帧和数据帧, 在原来的HTTP版本中, 是明文传输的, 但是在HTTP2.0中直接使用了二进制, 无需将明文转换为二进制

### 并发原理

那么HTTP2.0是如何实现并发传输的呢? 原理也很简单, HTTP2.0中引入了`Stream`的概念, 在一个TCP连接中可以有多个Stream, 每个Stream有不同的id, 在其中也会有不同的request和response的请求和响应, 那么再里面就是我们熟悉的`帧`, 由于Stream之间都是独立的, 所以可以乱序发送, 然后在客户端会根据id拼接HTTP消息, 这就是HTTP2.0并发传输的原理.

### 服务端推送

服务端推送也和Stream理念不可分割, 因为在1.0和1.1都是请求应答传统模式, 即客户端请求, 服务端应答, 在HTTP2中对这个模式进行了优化. 在客户端和服务端分别建立Stream, 它们的id略有不同, 客户端是`奇数`, 而服务端是`偶数`. 那么服务端推送有什么好处呢? 最大的好处就是减少网络次数往返, 比如客户端接受一个html文件, 那么在html中又引入了css,js等文件, 那么我们就可以用服务端推送html中的css和js文件, 减少了消息传递次数.

### HTTP3

看似HTTP2很完美了, 该有的都有了, 但是我们仔细想一下, HTTP2解决的队头阻塞看样子是通过Stream完美解决了, 但是HTTP2是基于TCP的, TCP是字节流协议, 它最大的特点就是要保证数据是连续并且完整的, 它有一个`缓冲区`的概念, 当前一个请求缺少字节的时候, 只能将这部分数据保存到缓冲区中, 等字节达到之后, 才可以被HTTP这个应用层获取到数据. 也就是说, 我们虽然解决了HTTP队头阻塞, 但是并没有解决TCP的队头阻塞, 所以要想完美的解决这个问题, 我们只能使用`UDP`

那么, TCP是可靠传输, UDP是不可靠传输, HTTP3是如何底层使用UDP的呢, 原因就是使用了UDP为底层的`QUIC`协议, 它完美解决了队头阻塞, 即就算某个Stream丢包, 也不会影响其他Stream 而且在QUIC协议中, 对建立连接做了很多优化, 比如说在HTTP2之前与TLS握手, 都要建立三次; 但是在QUIC中, 因为其包含了TLS, 并且使用TLS的更高版本, 可以在HTTP的三次握手中进行TLS信息的携带, 所以可以说把TLS的握手过程隐藏了.

那么为什么HTTP2不把TLS进行囊括合并呢? 是因为TCP是内核实现的传输层, TLS是openssl实现的表示层, 无法合并

## HTTPS

HTTPS就是在TLS/SSL基础上的一个应用, 我们在HTTP中发送的数据都是明文的, 这并不安全会带来很多隐患; 通过SSL校验服务端身份, 并且在通信过程中间加密; 那么它们的建立连接的过程可以分为以下几步

- 发起HTTPS请求
- 服务端返回SSL证书的public key
- 客户端自己生成一个对称加密的public key
- 拿SSL的public key加密刚刚生成的public key, 并且发送
- 之后客户端发送的消息都会拿刚刚加密过后的public key对数据进行加密

### 区别

- SSL证书要钱, 但是大部分是免费的
- 多一个TSL握手的过程
- 一个明文, 一个是密文
- HTTP默认端口是80, HTTPS是443

## OSI七层模型

OSI将网络体系划分为7层, 7层互不干扰, 每一层互相独立协议, 并且独立完成和相邻接口通信功能

### 应用层

我们熟悉的DNS, HTTP, SMTP都是应用层

### 表示层

主要作用就是让数据能够解释和交换

### 会话层

建立, 管理会话

### ****传输层****

TCP/UDP

### 网络层

IP

### 数据链路层

令牌环网

### 物理层

以太网

## TCP/IP4层模型

TCP模型比OSI模型更为抽象, 它将应用, 会话, 表示都称之为应用层, 将数据链路层和物理层称之为网络接口层

## DNS解析

简单说DNS就是一个翻译官, 把我们的域名翻译为IP地址, DNS查询的过程可以简述为

- 查浏览器
- 查操作系统
- 查本地域名服务器
- 查上游服务器
- 给本地域名服务器缓存ip信息
- 给操作系统缓存ip信息
- 给浏览器缓存ip信息

## TCP的三握四挥

三次握手的作用就是, 其实就是小明小红打电话

- 小明: 小红听到了么 (客户端发送正常)
- 小红: 我能听到的 (服务端发送和接收正常, 但是此时小红不确定小明的接收是不是正常的)
- 小明: 那我开始说了 (此时2个端的发送和接收都是正常的)

四次挥手也是一样的, 也就是挂电话的逻辑

- 小明: 我说完了, 你还有啥要说的么
- 小红: 好吧, 我这里也没了
- 小明: 那我挂了
- 小红: 行, 你挂吧, 我也挂了

## 经典八股文: 浏览器地址输入到显示经历了哪些步骤

哪个前端面试没背过的, 都不配称之为前端.哈哈哈哈哈

我们简单过一下这一块, 虽然这里烂大街了

- 首先就是对输入的内容进行解析

> 浏览器要判断你输入的是一个网址, 还是一个关键词
> 
- 如果是网址, 那就经过DNS解析拿到IP地址

> DNS查询过程请看上方
> 
- 建立TCP连接

> 详见小明打电话的例子
> 
- 发送HTTP请求
- 响应HTTP请求

> 对资源进行解析, 主要看content-type, 还有gzip等等, 需要对返回内容作处理
> 
- 渲染页面

> 解析和构造dom树 → 解析和构造css树 → 合并生成render树 → 布局layout树 → 绘制像素树 → 通知gpu进行绘制显示在屏幕上
>