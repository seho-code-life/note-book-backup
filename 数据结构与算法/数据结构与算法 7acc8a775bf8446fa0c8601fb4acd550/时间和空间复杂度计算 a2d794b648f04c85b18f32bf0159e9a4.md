# 时间和空间复杂度计算

时间和空间复杂度就是一个函数，由O表示

时间复杂度指的虽然不是代码运行的时间，是指的是运行趋势量度，常用的表达有以下几个：

```jsx
O(1)
O(logN)
O(n)
O(n²)
```

下面的代码示例是一个典型的O(1)的时间复杂度，因为代码中没有循环等复杂结构体，只有纯粹的命令表达式，无论有多少行代码，它始终都是O(1)

```jsx
let i = 0;
i++;
```

典型示例：循环的时间是由N决定的，N越大循环时间越长，值得注意的是尽管循环下面跟了时间复杂度为O(1)的代码，它们是同级关系，会取时间复杂度更大的一个，即O(n)，O(1)的代码忽略不计了;

```jsx
for(let i = 0;i<n;i++){
	console.log(i);
}
let i = 0;
i++;
```

对数阶O(n)的O(logN)典型示例：在这个while循环中，i会*2，依次循环会距离n越来越近直到退出循环，也就是说当循环log2的n次方的时候，就完事了，所以时间复杂度是O(logn);

```jsx
let i = 1;
while(i<n){
	i = i * 2;
}
```

线性对数阶O(nlogN)，把对数阶的代码进行n次循环就是线性对数阶：

即：n * O(logN) = O(nLogN)

```jsx
for(let m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

O(n²)典型示例：循环中嵌套，要把时间复杂度去相乘即：

O(n) * O(n) = O(n²)

```jsx
for(let i = 0;i<n;i++){
	for(let i = 0;i<n;i++){
		console.log(i);
	}
}
```

空间复杂度：

O(1): 如果算法执行所需要的空间不需要跟随着某个变量大小而变化，那么它就是O(1):

```jsx
let i = 0;
i++;
```

O(n): 数组随着n的值变化，内存而增大，循环不用管，因为循环中没有去增加数组的空间，因此看第一行就好。

```jsx
const array = [n];
for(let i = 0;i>n;i++){
	
}
```